---
title: scriptTest
layout: post
date: 2020-06-04
permalink: /blog/scriptTest
comments: true
mathjax: true
---

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>R12/Ishank Juneja/16D070012</title>
  <style type="text/css">code{white-space: pre;}</style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
</head>
<body>
<div id="header">
<h1 class="title">R12/Ishank Juneja/16D070012</h1>
</div>
<h2 id="introduction">Introduction</h2>
<p>Under the classic Markov Decision Process (MDP) setup, we associate a tuple <span class="math inline">\((S, A, T, R)\)</span> with every MDP. In this notation, <span class="math inline">\(S\)</span> is the set of states the agent can take, <span class="math inline">\(A\)</span> is the set of possible actions for the agent, <span class="math inline">\(T:S \times A \rightarrow \Pi(s)\)</span> is the state transition function of the problem. <span class="math inline">\(T\)</span> specifies the probability distribution over next states <span class="math inline">\(s&#39; \in S\)</span> on taking an action <span class="math inline">\(a \in A\)</span> starting from state <span class="math inline">\(s \in S\)</span>. <span class="math inline">\(R\)</span> is the reward function which can be viewed as a feedback on agent performance from the environment. An assumption implicit to this model is the observability of state <span class="math inline">\(s \in S\)</span>. Often times, it is not the case that an agent has access to its exact state. Instead, the agent might only have access to an observation <span class="math inline">\(o \in \Omega\)</span> which captures incomplete information about its underlying state. This framework satisfactorily models many practical situations. For instance, consider a robot that is attempting to localize its position (directly unobservable state <span class="math inline">\(s\)</span>) in a multi-storied building by merely looking at a particular intersection in a corridor (observation <span class="math inline">\(o\)</span>). Partially Observable MDPs (POMDPs) provide a richer mathematical framework which is able to describe many such situations.</p>
<h2 id="the-pomdp-framework" class="unnumbered">The POMDP Framework</h2>
<p>A POMDP is completely described by the tuple <span class="math inline">\((S, A, T, R, \Omega, O)\)</span>, where<br />
<span class="math inline">\((S, A, T, R)\)</span> is the underlying MDP, <span class="math inline">\(\Omega\)</span> is a finite set of observations the agent can experience and <span class="math inline">\(O:S \times A \rightarrow \Pi(\Omega)\)</span> is the observation function which gives, for every state and action, a probability distribution over possible observations. Under the POMDP framework an agent is unable to discern its state accurately. Instead of the true state, the agent makes “an observation” <span class="math inline">\(o\)</span> based on the action <span class="math inline">\(a\)</span> taken and the (still unobserved) resulting state <span class="math inline">\(s&#39;\)</span>.<br />
An implication of this limitation is that an agent wishing to act optimally must use its memory of all previous actions and observations. To simplify the problem, the POMDP model introduces a <em>belief state</em> <span class="math inline">\(b\)</span>. Belief states are probability distributions over the true underlying states of the agent. That is, for each state <span class="math inline">\(s\)</span>, <span class="math inline">\(b(s)\)</span> gives the probability of the agent being in that state. By design, the agents belief state at any point of time is a sufficient statistic (SS) for all its previous experience. As a SS, the belief states capture all the past observations and the belief state that the agent started with. Sequential decision-making in the POMDP becomes Markovian in belief state <span class="math inline">\(b\)</span> due to the SS property.<br />
To compute and update belief states as new experience is accumulated, the agent includes a block known as the state-estimator (SE). More precisely, given an observation <span class="math inline">\(o\)</span>, the action taken <span class="math inline">\(a\)</span> and the previous belief state <span class="math inline">\(b\)</span>, the SE is the function SE<span class="math inline">\((b, a, o)\)</span> which outputs the new belief state <span class="math inline">\(b&#39;\)</span>. Using the rules of conditional probability and the definitions of the POMDP parameters, the paper derives the relation <span class="math display">\[b&#39;(s&#39;) \propto O(s&#39;, a, o)\sum_{s \in S}T(s, a, s&#39;)b(s),\]</span> where the probabilities in <span class="math inline">\(b&#39;\)</span> are computed using the constraint <span class="math inline">\(\sum_{s \in S}b(s) = 1\)</span>.<br />
The other necessary component to describe a POMDP agent is the policy being followed by it. In the POMDP framework, a policy maps a belief state vector <span class="math inline">\(b\)</span> to an action <span class="math inline">\(a\)</span>. Since the problem is Markovian in the belief state <span class="math inline">\(b\)</span>, obtaining a policy through POMDP planning is equivalent to solving the planning problem for an associated <strong>belief MDP</strong>.<br />
The parameters for the belief MDP are described below,</p>
<ul>
<li><p><span class="math inline">\(\mathcal{B}\)</span> is the set of possible belief states and forms the state space</p></li>
<li><p>The set of actions <span class="math inline">\(A\)</span> remains the same as the POMDP</p></li>
<li><p><span class="math inline">\(\tau(b,a,b&#39;)\)</span> is the state-transition function which can be computed using the POMDP parameters</p></li>
<li><p><span class="math inline">\(\rho(b, a)\)</span> is the reward function and is given by an expectation over the reward function <span class="math inline">\(R(s, a)\)</span> under the distribution over states given by <span class="math inline">\(b(s)\)</span></p></li>
</ul>
<h2 id="planning-for-pomdps" class="unnumbered">Planning for POMDPs</h2>
<p>It is often intractable to solve the planning problem for continuous state MDPs, however the special structure of the belief MDP lends it properties that give rise to efficient planning algorithms. In this paper the authors focus primarily on two planning approaches - <strong>Exhaustive Enumeration and Witness Algorithm</strong> the latter among which is a novel approach. Both methods provide a means to determine the optimal <span class="math inline">\(t\)</span> - step value function <span class="math inline">\(V_t\)</span> given a start belief state <span class="math inline">\(b\)</span>. Here <span class="math inline">\(t\)</span> - step refers to the situation where there are only <span class="math inline">\(t\)</span> steps remaining in the agents lifetime. The paper considers the more general finite horizon problem since an infinite horizon discounted trajectory can always be approximated to arbitrary precision by a long enough finite trajectory. Lastly, once the optimal value function is computed using Value-Iteration, it is a straightforward task to determine the optimal policy to complete planning.<br />
Next, the paper describes how a <span class="math inline">\(t\)</span>-step policy can be represented using a <em>policy tree</em> - <span class="math inline">\(p\)</span> of depth <span class="math inline">\(t\)</span>. An expression for the expected return <span class="math inline">\(V_p(s)\)</span> associated with executing the policy <span class="math inline">\(p\)</span>, starting from a state <span class="math inline">\(s\)</span>, can be derived using the belief MDP parameters. However, the actual quantity of interest is the return for a given <em>belief state</em> <span class="math inline">\(b\)</span>. Using the linearity of expectations we have, <span class="math inline">\(V_p(b) = \sum_{s \in S} b(s) V_p(s)\)</span>. Treating <span class="math inline">\(b\)</span> and <span class="math inline">\(V_p\)</span> as vectors of length <span class="math inline">\(|S|\)</span>, <span class="math inline">\(V_p\)</span> becomes a dot product.<br />
The objective of planning through value-iteration is to obtain <span class="math display">\[V_t(b) = \max_{p \in \mathcal{P}} b \cdot V_p.\]</span></p>
<h3 id="pruning-the-search-space" class="unnumbered">Pruning the Search space</h3>
<p>Using geometrical arguments the authors were able to show that the optimal value function <span class="math inline">\(V_t\)</span> is piecewise linear and convex. Such a <span class="math inline">\(V_t\)</span> induces a partition on the space of possible belief states such that for every <span class="math inline">\(b\)</span> there exists an optimal policy tree. While iterating over value functions, we would be much better of if our search space were as compact as possible. To do achieve this, we keep only <em>useful</em> policy trees and prune way the others. A policy tree <span class="math inline">\(p&#39;\)</span> is considered useful if its value function <span class="math inline">\(V_{p&#39;}\)</span> is such that it cannot be dominated everywhere by the maximum of the value functions of any subset of <span class="math inline">\(\mathcal{P}\)</span>. A possible way of ensuring that we have a minimal subset is to ensure that for every policy, there is at least one point in the state space where its own value function dominates. Once a minimal representation (set of policies) <span class="math inline">\(\mathcal{V}_t\)</span> for the optimal value function <span class="math inline">\(V_t\)</span> is obtained, value iteration (VI) can be applied to the problem in a manner identical to that of VI for <strong>discrete</strong> MDPs.<br />
The only problem left to be solved then is that of obtaining a minimal representation of the <span class="math inline">\(t\)</span> step optimal value function given a minimal representation of the <span class="math inline">\(t-1\)</span> step value function <span class="math inline">\(V_{t-1}\)</span>. The next two algorithms achieve this.</p>
<h3 id="exhaustive-enumeration" class="unnumbered">Exhaustive Enumeration</h3>
<p>This algorithm works by constructing a superset <span class="math inline">\(\mathcal{V}_t^{+}\)</span> of the minimal set and then pruning it down to <span class="math inline">\(\mathcal{V}_t\)</span>. The algorithm can be broken down into two steps - generation and pruning. To generate the superset <span class="math inline">\(\mathcal{V}_t^{+}\)</span>, we only need to consider the policy trees contained in <span class="math inline">\(\mathcal{V}_{t-1}\)</span> since a policy with a non-useful subtree cannot itself be useful. This means that the superset will contain <span class="math inline">\(|A||\mathcal{V}_{t-1}|^{\Omega}\)</span> elements.<br />
To prune the superset, we can identify the optimal parent <span class="math inline">\(t\)</span> length policy for each <span class="math inline">\(t-1\)</span> length sub-policy using linear programming. For this we would need to compute the value functions for each of the policy trees in <span class="math inline">\(\mathcal{V}_t^{+}\)</span>. This can be done efficiently using the value functions of the sub-trees.<br />
The main drawback of this approach is that we need to go through the superset <span class="math inline">\(\mathcal{V}_t^{+}\)</span> which has a size exponential in the number of possible observations <span class="math inline">\(|\Omega|\)</span>.</p>
<h3 id="witness-algorithm---authors-novel-approach" class="unnumbered">Witness Algorithm - Authors’ Novel Approach</h3>
<p>Instead of computing <span class="math inline">\(\mathcal{V}_t\)</span> directly, the witness algorithm computes a set <span class="math inline">\(\mathcal{Q}_t^{a}\)</span> for every action <span class="math inline">\(a\)</span>. <span class="math inline">\(\mathcal{Q}_t^{a}\)</span> represents the set of all <span class="math inline">\(t\)</span> step policy trees with the action <span class="math inline">\(a\)</span> at their root. The set <span class="math inline">\(\mathcal{V}_t\)</span> is then computed by pruning the union of such policies trees - <span class="math inline">\(\cup_a \mathcal{Q}_t^{a}\)</span>. The job of the witness algorithm is to provide an <em>efficient</em> technique to compute <span class="math inline">\(\mathcal{Q}_t^{a}\)</span>. In particular the authors show that their algorithm has complexity polynomial in <span class="math inline">\(|S|,|A|,|\Omega|,|\mathcal{V}_{t-1}|\)</span> and <span class="math inline">\(|\mathcal{Q}_t^{a}|\)</span>. A caveat here is that <span class="math inline">\(|\mathcal{Q}_t^{a}|\)</span> can be exponentially larger than the size of <span class="math inline">\(\mathcal{V}_t\)</span>.<br />
The core of the witness algorithm lies in its pruning technique. The algorithm starts of with a single policy tree optimal for some arbitrary belief state <span class="math inline">\(b\)</span>. Then we check if there exists a belief state <span class="math inline">\(b\)</span> for which the <span class="math inline">\(Q\)</span> value estimated using our current set of trees - <span class="math inline">\(\hat{\mathcal{Q}}_{t}^{a}(b)\)</span> is less than the true <span class="math inline">\(Q\)</span> value given by <span class="math inline">\(\mathcal{Q}_{t}^{a}(b)\)</span>. Such a <span class="math inline">\(b\)</span> is said to serve as a <em>witness</em> to the fact that our current collection of policy trees is incomplete. Once such a witness is identified, the algorithm appends the policy, with action <span class="math inline">\(a\)</span> at the root, that yields the best value for the earlier chosen belief state <span class="math inline">\(b\)</span>. This process continues until no more witness points exist and we conclude that our representation of <span class="math inline">\(Q\)</span> is perfect. Since the belief space is continuous, the search for witnesses <span class="math inline">\(b\)</span> is achieved using linear programming.<br />
The witness algorithm fails to perform well on problems where <span class="math inline">\(|\mathcal{Q}_t^{a}|\)</span> is “not polynomial&quot;. In such situations the authors point to other algorithms such as the briefly described <em>linear support algorithm</em>.</p>
<h2 id="obtaining-a-minimal-finite-state-controller" class="unnumbered">Obtaining a Minimal Finite State Controller</h2>
<p>For some special POMDP problems, the optimal policy trees have the property that the observation-action mapping at every level remains the same. In such situations the policy becomes stationary and can be represented as a more compact plan-graph. The way a plan graph is created, on every step an agent could start of in the node optimal for its initial belief state and thereafter simply make observations and follow the arc associated with the observation to the next node. This picture is essentially that of a finite state controller which uses the minimal possible amount of memory to act optimally in a POMDP environment. As the paper points out, it is fascinating that the POMDP problem started off as a discrete problem, was converted to a continuous belief space and at the end the continuous solution could again be mapped back to a discrete controller.<br />
Some questions I have are -</p>
<ul>
<li><p>What exactly is the efficient pruning strategy for obtaining the minimal useful set <span class="math inline">\(\mathcal{V}\)</span> of policy trees? It seemed to me that we can’t do without ensuring that every policy we throw out does not dominate all other policies for some <span class="math inline">\(b \in \mathcal{B}\)</span>.</p></li>
<li><p>In the description of the witness algorithm (WA), the authors claim that the running time of WA is polynomial if <span class="math inline">\(|\mathcal{Q}_t^{a}|\)</span> is polynomial. What is meant by the latter being polynomial? What problem parameters are being refereed to?</p></li>
</ul>
</body>
</html>
